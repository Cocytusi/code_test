/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "../../../../../common";

export declare namespace ProfessionStakingHarmony {
  export type TrainingStatusStruct = {
    _address: PromiseOrValue<string>;
    tokenId: PromiseOrValue<BigNumberish>;
    level: PromiseOrValue<BigNumberish>;
    treeId: PromiseOrValue<BigNumberish>;
    skillId: PromiseOrValue<BigNumberish>;
    startedAt: PromiseOrValue<BigNumberish>;
    completeAt: PromiseOrValue<BigNumberish>;
  };

  export type TrainingStatusStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    _address: string;
    tokenId: BigNumber;
    level: BigNumber;
    treeId: BigNumber;
    skillId: BigNumber;
    startedAt: BigNumber;
    completeAt: BigNumber;
  };

  export type NFTStruct = {
    _address: PromiseOrValue<string>;
    tokenId: PromiseOrValue<BigNumberish>;
    rewardFrom: PromiseOrValue<BigNumberish>;
  };

  export type NFTStructOutput = [string, BigNumber, BigNumber] & {
    _address: string;
    tokenId: BigNumber;
    rewardFrom: BigNumber;
  };
}

export interface ProfessionStakingHarmonyInterface extends utils.Interface {
  functions: {
    "DEFAULT_ADMIN_ROLE()": FunctionFragment;
    "GAME_STORAGE()": FunctionFragment;
    "LAST_REWARD_TIME()": FunctionFragment;
    "PAUSER_ROLE()": FunctionFragment;
    "UPDATER_ROLE()": FunctionFragment;
    "adminBatchUpdateNftData(address[],uint256[],address[],uint256[],uint256[])": FunctionFragment;
    "adminGetData(address)": FunctionFragment;
    "adminUpdateNftData(address,uint256,address,uint256,uint256)": FunctionFragment;
    "batchCancelTraining(address[],uint256[])": FunctionFragment;
    "batchClaimAndUnstakeForUser(address[])": FunctionFragment;
    "batchEnableStaking(address[],uint256[])": FunctionFragment;
    "batchFinishTraining(address[],uint256[])": FunctionFragment;
    "batchSetTrainingCosts(uint256[],uint256[],uint256[])": FunctionFragment;
    "batchStake(address[],uint256[])": FunctionFragment;
    "batchStartTraining(address[],uint256[],uint256[],uint256[])": FunctionFragment;
    "batchUnstake(address[],uint256[])": FunctionFragment;
    "cancelTraining(address,uint256)": FunctionFragment;
    "claim()": FunctionFragment;
    "claimAndUnstakeForUser(address)": FunctionFragment;
    "createStakingConfig(address,address,uint256,uint256,uint256[],uint256[])": FunctionFragment;
    "deleteStakingConfig(address)": FunctionFragment;
    "enableStaking(address,uint256)": FunctionFragment;
    "finishTraining(address,uint256)": FunctionFragment;
    "forceCancelTraining(address,address,uint256)": FunctionFragment;
    "getActiveTraining()": FunctionFragment;
    "getActiveTrainingOf(address)": FunctionFragment;
    "getAllParticipantData()": FunctionFragment;
    "getAllowedSkillChoices(address,uint256)": FunctionFragment;
    "getRoleAdmin(bytes32)": FunctionFragment;
    "getStaked()": FunctionFragment;
    "getStakedOf(address)": FunctionFragment;
    "getTotalProfessionSkillPoints(address,uint256)": FunctionFragment;
    "getTrainingStatus(address,address,uint256)": FunctionFragment;
    "grantRole(bytes32,address)": FunctionFragment;
    "hasRole(bytes32,address)": FunctionFragment;
    "initialize()": FunctionFragment;
    "isStakingEnabled(address,uint256)": FunctionFragment;
    "modifyActiveTrainingSkill(address,address,uint256,uint256)": FunctionFragment;
    "onERC721Received(address,address,uint256,bytes)": FunctionFragment;
    "pause()": FunctionFragment;
    "paused()": FunctionFragment;
    "pendingRewards()": FunctionFragment;
    "pendingRewardsOf(address)": FunctionFragment;
    "renounceRole(bytes32,address)": FunctionFragment;
    "revokeRole(bytes32,address)": FunctionFragment;
    "setGameStorage(address)": FunctionFragment;
    "setLastRewardTime(uint256)": FunctionFragment;
    "setSkillPointer(address,uint256,uint256)": FunctionFragment;
    "setTrainingCost(uint256,uint256,uint256)": FunctionFragment;
    "stake(address,uint256)": FunctionFragment;
    "startTraining(address,uint256,uint256,uint256)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "unpause()": FunctionFragment;
    "unstake(address,uint256)": FunctionFragment;
    "updateStakingConfig(address,address,uint256,uint256)": FunctionFragment;
    "withdrawPoolRewards(address,address,uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "DEFAULT_ADMIN_ROLE"
      | "GAME_STORAGE"
      | "LAST_REWARD_TIME"
      | "PAUSER_ROLE"
      | "UPDATER_ROLE"
      | "adminBatchUpdateNftData"
      | "adminGetData"
      | "adminUpdateNftData"
      | "batchCancelTraining"
      | "batchClaimAndUnstakeForUser"
      | "batchEnableStaking"
      | "batchFinishTraining"
      | "batchSetTrainingCosts"
      | "batchStake"
      | "batchStartTraining"
      | "batchUnstake"
      | "cancelTraining"
      | "claim"
      | "claimAndUnstakeForUser"
      | "createStakingConfig"
      | "deleteStakingConfig"
      | "enableStaking"
      | "finishTraining"
      | "forceCancelTraining"
      | "getActiveTraining"
      | "getActiveTrainingOf"
      | "getAllParticipantData"
      | "getAllowedSkillChoices"
      | "getRoleAdmin"
      | "getStaked"
      | "getStakedOf"
      | "getTotalProfessionSkillPoints"
      | "getTrainingStatus"
      | "grantRole"
      | "hasRole"
      | "initialize"
      | "isStakingEnabled"
      | "modifyActiveTrainingSkill"
      | "onERC721Received"
      | "pause"
      | "paused"
      | "pendingRewards"
      | "pendingRewardsOf"
      | "renounceRole"
      | "revokeRole"
      | "setGameStorage"
      | "setLastRewardTime"
      | "setSkillPointer"
      | "setTrainingCost"
      | "stake"
      | "startTraining"
      | "supportsInterface"
      | "unpause"
      | "unstake"
      | "updateStakingConfig"
      | "withdrawPoolRewards"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "DEFAULT_ADMIN_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "GAME_STORAGE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "LAST_REWARD_TIME",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PAUSER_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "UPDATER_ROLE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "adminBatchUpdateNftData",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "adminGetData",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "adminUpdateNftData",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchCancelTraining",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchClaimAndUnstakeForUser",
    values: [PromiseOrValue<string>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchEnableStaking",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchFinishTraining",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchSetTrainingCosts",
    values: [
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchStake",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "batchStartTraining",
    values: [
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "batchUnstake",
    values: [PromiseOrValue<string>[], PromiseOrValue<BigNumberish>[]]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelTraining",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "claim", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "claimAndUnstakeForUser",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "createStakingConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deleteStakingConfig",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "enableStaking",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "finishTraining",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "forceCancelTraining",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveTraining",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveTrainingOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getAllParticipantData",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAllowedSkillChoices",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getRoleAdmin",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "getStaked", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getStakedOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalProfessionSkillPoints",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTrainingStatus",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "grantRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "hasRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "initialize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isStakingEnabled",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "modifyActiveTrainingSkill",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "onERC721Received",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string;
  encodeFunctionData(functionFragment: "pause", values?: undefined): string;
  encodeFunctionData(functionFragment: "paused", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "pendingRewards",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "pendingRewardsOf",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "revokeRole",
    values: [PromiseOrValue<BytesLike>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setGameStorage",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setLastRewardTime",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "setSkillPointer",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrainingCost",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "stake",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "startTraining",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(functionFragment: "unpause", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "unstake",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "updateStakingConfig",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdrawPoolRewards",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;

  decodeFunctionResult(
    functionFragment: "DEFAULT_ADMIN_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "GAME_STORAGE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "LAST_REWARD_TIME",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PAUSER_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "UPDATER_ROLE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "adminBatchUpdateNftData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "adminGetData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "adminUpdateNftData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchCancelTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchClaimAndUnstakeForUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchEnableStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchFinishTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchSetTrainingCosts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "batchStake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "batchStartTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "batchUnstake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claim", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimAndUnstakeForUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createStakingConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deleteStakingConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enableStaking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finishTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "forceCancelTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveTrainingOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllParticipantData",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAllowedSkillChoices",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRoleAdmin",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getStaked", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getStakedOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalProfessionSkillPoints",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTrainingStatus",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "grantRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "hasRole", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isStakingEnabled",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "modifyActiveTrainingSkill",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "onERC721Received",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "pause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "paused", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "pendingRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pendingRewardsOf",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "revokeRole", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setGameStorage",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setLastRewardTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setSkillPointer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTrainingCost",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "stake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "startTraining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "unpause", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "unstake", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updateStakingConfig",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdrawPoolRewards",
    data: BytesLike
  ): Result;

  events: {
    "ClaimBlocked(address,uint256,uint256)": EventFragment;
    "Claimed(address,address,uint256)": EventFragment;
    "Initialized(uint8)": EventFragment;
    "Paused(address)": EventFragment;
    "PoolRewardsDeposited(address,address,uint256)": EventFragment;
    "PoolRewardsWithdrawn(address,address,address,uint256)": EventFragment;
    "RoleAdminChanged(bytes32,bytes32,bytes32)": EventFragment;
    "RoleGranted(bytes32,address,address)": EventFragment;
    "RoleRevoked(bytes32,address,address)": EventFragment;
    "Staked(address,address,uint256)": EventFragment;
    "StakingConfigCreated(address,address,uint256)": EventFragment;
    "StakingConfigDeleted(address)": EventFragment;
    "StakingConfigUpdated(address,address,uint256)": EventFragment;
    "StakingUnlocked(address,address,uint256)": EventFragment;
    "TrainingCanceled(address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "TrainingFinished(address,address,uint256,uint256,uint256,uint256)": EventFragment;
    "TrainingStarted(address,address,uint256,uint256,uint256,uint256,uint256,uint256)": EventFragment;
    "Unpaused(address)": EventFragment;
    "Unstaked(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ClaimBlocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Claimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Initialized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Paused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PoolRewardsDeposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PoolRewardsWithdrawn"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleAdminChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleGranted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RoleRevoked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Staked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingConfigCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingConfigDeleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingConfigUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakingUnlocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TrainingCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TrainingFinished"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TrainingStarted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unpaused"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Unstaked"): EventFragment;
}

export interface ClaimBlockedEventObject {
  from: string;
  stakedCount: BigNumber;
  amount: BigNumber;
}
export type ClaimBlockedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  ClaimBlockedEventObject
>;

export type ClaimBlockedEventFilter = TypedEventFilter<ClaimBlockedEvent>;

export interface ClaimedEventObject {
  by: string;
  token: string;
  amount: BigNumber;
}
export type ClaimedEvent = TypedEvent<
  [string, string, BigNumber],
  ClaimedEventObject
>;

export type ClaimedEventFilter = TypedEventFilter<ClaimedEvent>;

export interface InitializedEventObject {
  version: number;
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>;

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>;

export interface PausedEventObject {
  account: string;
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>;

export type PausedEventFilter = TypedEventFilter<PausedEvent>;

export interface PoolRewardsDepositedEventObject {
  from: string;
  token: string;
  amount: BigNumber;
}
export type PoolRewardsDepositedEvent = TypedEvent<
  [string, string, BigNumber],
  PoolRewardsDepositedEventObject
>;

export type PoolRewardsDepositedEventFilter =
  TypedEventFilter<PoolRewardsDepositedEvent>;

export interface PoolRewardsWithdrawnEventObject {
  by: string;
  to: string;
  token: string;
  amount: BigNumber;
}
export type PoolRewardsWithdrawnEvent = TypedEvent<
  [string, string, string, BigNumber],
  PoolRewardsWithdrawnEventObject
>;

export type PoolRewardsWithdrawnEventFilter =
  TypedEventFilter<PoolRewardsWithdrawnEvent>;

export interface RoleAdminChangedEventObject {
  role: string;
  previousAdminRole: string;
  newAdminRole: string;
}
export type RoleAdminChangedEvent = TypedEvent<
  [string, string, string],
  RoleAdminChangedEventObject
>;

export type RoleAdminChangedEventFilter =
  TypedEventFilter<RoleAdminChangedEvent>;

export interface RoleGrantedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleGrantedEvent = TypedEvent<
  [string, string, string],
  RoleGrantedEventObject
>;

export type RoleGrantedEventFilter = TypedEventFilter<RoleGrantedEvent>;

export interface RoleRevokedEventObject {
  role: string;
  account: string;
  sender: string;
}
export type RoleRevokedEvent = TypedEvent<
  [string, string, string],
  RoleRevokedEventObject
>;

export type RoleRevokedEventFilter = TypedEventFilter<RoleRevokedEvent>;

export interface StakedEventObject {
  from: string;
  nftAddress: string;
  tokenId: BigNumber;
}
export type StakedEvent = TypedEvent<
  [string, string, BigNumber],
  StakedEventObject
>;

export type StakedEventFilter = TypedEventFilter<StakedEvent>;

export interface StakingConfigCreatedEventObject {
  nftAddress: string;
  rewardToken: string;
  startTime: BigNumber;
}
export type StakingConfigCreatedEvent = TypedEvent<
  [string, string, BigNumber],
  StakingConfigCreatedEventObject
>;

export type StakingConfigCreatedEventFilter =
  TypedEventFilter<StakingConfigCreatedEvent>;

export interface StakingConfigDeletedEventObject {
  nftAddress: string;
}
export type StakingConfigDeletedEvent = TypedEvent<
  [string],
  StakingConfigDeletedEventObject
>;

export type StakingConfigDeletedEventFilter =
  TypedEventFilter<StakingConfigDeletedEvent>;

export interface StakingConfigUpdatedEventObject {
  nftAddress: string;
  rewardToken: string;
  startTime: BigNumber;
}
export type StakingConfigUpdatedEvent = TypedEvent<
  [string, string, BigNumber],
  StakingConfigUpdatedEventObject
>;

export type StakingConfigUpdatedEventFilter =
  TypedEventFilter<StakingConfigUpdatedEvent>;

export interface StakingUnlockedEventObject {
  by: string;
  nftAddress: string;
  tokenId: BigNumber;
}
export type StakingUnlockedEvent = TypedEvent<
  [string, string, BigNumber],
  StakingUnlockedEventObject
>;

export type StakingUnlockedEventFilter = TypedEventFilter<StakingUnlockedEvent>;

export interface TrainingCanceledEventObject {
  by: string;
  nftAddress: string;
  tokenId: BigNumber;
  treeId: BigNumber;
  skillId: BigNumber;
  canceledAt: BigNumber;
}
export type TrainingCanceledEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  TrainingCanceledEventObject
>;

export type TrainingCanceledEventFilter =
  TypedEventFilter<TrainingCanceledEvent>;

export interface TrainingFinishedEventObject {
  by: string;
  nftAddress: string;
  tokenId: BigNumber;
  treeId: BigNumber;
  skillId: BigNumber;
  level: BigNumber;
}
export type TrainingFinishedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber, BigNumber, BigNumber],
  TrainingFinishedEventObject
>;

export type TrainingFinishedEventFilter =
  TypedEventFilter<TrainingFinishedEvent>;

export interface TrainingStartedEventObject {
  by: string;
  nftAddress: string;
  tokenId: BigNumber;
  treeId: BigNumber;
  skillId: BigNumber;
  level: BigNumber;
  startedAt: BigNumber;
  completeAt: BigNumber;
}
export type TrainingStartedEvent = TypedEvent<
  [
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ],
  TrainingStartedEventObject
>;

export type TrainingStartedEventFilter = TypedEventFilter<TrainingStartedEvent>;

export interface UnpausedEventObject {
  account: string;
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>;

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>;

export interface UnstakedEventObject {
  from: string;
  nftAddress: string;
  tokenId: BigNumber;
}
export type UnstakedEvent = TypedEvent<
  [string, string, BigNumber],
  UnstakedEventObject
>;

export type UnstakedEventFilter = TypedEventFilter<UnstakedEvent>;

export interface ProfessionStakingHarmony extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ProfessionStakingHarmonyInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<[string]>;

    GAME_STORAGE(overrides?: CallOverrides): Promise<[string]>;

    LAST_REWARD_TIME(overrides?: CallOverrides): Promise<[BigNumber]>;

    PAUSER_ROLE(overrides?: CallOverrides): Promise<[string]>;

    UPDATER_ROLE(overrides?: CallOverrides): Promise<[string]>;

    adminBatchUpdateNftData(
      addresses: PromiseOrValue<string>[],
      indexes: PromiseOrValue<BigNumberish>[],
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      rewardFrom: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    adminGetData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        contractBalance: BigNumber;
        userPending: BigNumber;
      }
    >;

    adminUpdateNftData(
      _address: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      rewardFrom: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchCancelTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchClaimAndUnstakeForUser(
      addresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchEnableStaking(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchFinishTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchSetTrainingCosts(
      level: PromiseOrValue<BigNumberish>[],
      cost: PromiseOrValue<BigNumberish>[],
      time: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchStake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchStartTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    batchUnstake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    cancelTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claim(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    claimAndUnstakeForUser(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    createStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deleteStakingConfig(
      nftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    enableStaking(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    finishTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    forceCancelTraining(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getActiveTraining(
      overrides?: CallOverrides
    ): Promise<[ProfessionStakingHarmony.TrainingStatusStructOutput[]]>;

    getActiveTrainingOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[ProfessionStakingHarmony.TrainingStatusStructOutput[]]>;

    getAllParticipantData(
      overrides?: CallOverrides
    ): Promise<
      [string[], ProfessionStakingHarmony.NFTStructOutput[][], BigNumber[]] & {
        addresses: string[];
        nfts: ProfessionStakingHarmony.NFTStructOutput[][];
        rewards: BigNumber[];
      }
    >;

    getAllowedSkillChoices(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getStaked(
      overrides?: CallOverrides
    ): Promise<[ProfessionStakingHarmony.NFTStructOutput[]]>;

    getStakedOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[ProfessionStakingHarmony.NFTStructOutput[]]>;

    getTotalProfessionSkillPoints(
      ntfAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getTrainingStatus(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[ProfessionStakingHarmony.TrainingStatusStructOutput]>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    isStakingEnabled(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    modifyActiveTrainingSkill(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    paused(overrides?: CallOverrides): Promise<[boolean]>;

    pendingRewards(overrides?: CallOverrides): Promise<[BigNumber]>;

    pendingRewardsOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setGameStorage(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setLastRewardTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setSkillPointer(
      nftAddress: PromiseOrValue<string>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setTrainingCost(
      level: PromiseOrValue<BigNumberish>,
      cost: PromiseOrValue<BigNumberish>,
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    stake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    startTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unstake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    updateStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    withdrawPoolRewards(
      to: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;
  };

  DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

  GAME_STORAGE(overrides?: CallOverrides): Promise<string>;

  LAST_REWARD_TIME(overrides?: CallOverrides): Promise<BigNumber>;

  PAUSER_ROLE(overrides?: CallOverrides): Promise<string>;

  UPDATER_ROLE(overrides?: CallOverrides): Promise<string>;

  adminBatchUpdateNftData(
    addresses: PromiseOrValue<string>[],
    indexes: PromiseOrValue<BigNumberish>[],
    nftAddresses: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    rewardFrom: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  adminGetData(
    user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & {
      contractBalance: BigNumber;
      userPending: BigNumber;
    }
  >;

  adminUpdateNftData(
    _address: PromiseOrValue<string>,
    index: PromiseOrValue<BigNumberish>,
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    rewardFrom: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchCancelTraining(
    nftAddresses: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchClaimAndUnstakeForUser(
    addresses: PromiseOrValue<string>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchEnableStaking(
    nftAddresses: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchFinishTraining(
    nftAddresses: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchSetTrainingCosts(
    level: PromiseOrValue<BigNumberish>[],
    cost: PromiseOrValue<BigNumberish>[],
    time: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchStake(
    nftAddresses: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchStartTraining(
    nftAddresses: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    treeIds: PromiseOrValue<BigNumberish>[],
    skillIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  batchUnstake(
    nftAddresses: PromiseOrValue<string>[],
    tokenIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  cancelTraining(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claim(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  claimAndUnstakeForUser(
    _address: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  createStakingConfig(
    nftAddress: PromiseOrValue<string>,
    rewardToken: PromiseOrValue<string>,
    startTime: PromiseOrValue<BigNumberish>,
    maxPointsPerSkill: PromiseOrValue<BigNumberish>,
    treeIds: PromiseOrValue<BigNumberish>[],
    skillIds: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deleteStakingConfig(
    nftAddress: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  enableStaking(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  finishTraining(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  forceCancelTraining(
    _address: PromiseOrValue<string>,
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getActiveTraining(
    overrides?: CallOverrides
  ): Promise<ProfessionStakingHarmony.TrainingStatusStructOutput[]>;

  getActiveTrainingOf(
    _address: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<ProfessionStakingHarmony.TrainingStatusStructOutput[]>;

  getAllParticipantData(
    overrides?: CallOverrides
  ): Promise<
    [string[], ProfessionStakingHarmony.NFTStructOutput[][], BigNumber[]] & {
      addresses: string[];
      nfts: ProfessionStakingHarmony.NFTStructOutput[][];
      rewards: BigNumber[];
    }
  >;

  getAllowedSkillChoices(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getRoleAdmin(
    role: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  getStaked(
    overrides?: CallOverrides
  ): Promise<ProfessionStakingHarmony.NFTStructOutput[]>;

  getStakedOf(
    _address: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<ProfessionStakingHarmony.NFTStructOutput[]>;

  getTotalProfessionSkillPoints(
    ntfAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getTrainingStatus(
    _address: PromiseOrValue<string>,
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<ProfessionStakingHarmony.TrainingStatusStructOutput>;

  grantRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  hasRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  initialize(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  isStakingEnabled(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  modifyActiveTrainingSkill(
    _address: PromiseOrValue<string>,
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    skillId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  onERC721Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  pause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  paused(overrides?: CallOverrides): Promise<boolean>;

  pendingRewards(overrides?: CallOverrides): Promise<BigNumber>;

  pendingRewardsOf(
    _address: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  renounceRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  revokeRole(
    role: PromiseOrValue<BytesLike>,
    account: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setGameStorage(
    _address: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setLastRewardTime(
    time: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setSkillPointer(
    nftAddress: PromiseOrValue<string>,
    treeId: PromiseOrValue<BigNumberish>,
    skillId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setTrainingCost(
    level: PromiseOrValue<BigNumberish>,
    cost: PromiseOrValue<BigNumberish>,
    time: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  stake(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  startTraining(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    treeId: PromiseOrValue<BigNumberish>,
    skillId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  unpause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unstake(
    nftAddress: PromiseOrValue<string>,
    tokenId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  updateStakingConfig(
    nftAddress: PromiseOrValue<string>,
    rewardToken: PromiseOrValue<string>,
    startTime: PromiseOrValue<BigNumberish>,
    maxPointsPerSkill: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  withdrawPoolRewards(
    to: PromiseOrValue<string>,
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<string>;

    GAME_STORAGE(overrides?: CallOverrides): Promise<string>;

    LAST_REWARD_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    PAUSER_ROLE(overrides?: CallOverrides): Promise<string>;

    UPDATER_ROLE(overrides?: CallOverrides): Promise<string>;

    adminBatchUpdateNftData(
      addresses: PromiseOrValue<string>[],
      indexes: PromiseOrValue<BigNumberish>[],
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      rewardFrom: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    adminGetData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        contractBalance: BigNumber;
        userPending: BigNumber;
      }
    >;

    adminUpdateNftData(
      _address: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      rewardFrom: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    batchCancelTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchClaimAndUnstakeForUser(
      addresses: PromiseOrValue<string>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchEnableStaking(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchFinishTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchSetTrainingCosts(
      level: PromiseOrValue<BigNumberish>[],
      cost: PromiseOrValue<BigNumberish>[],
      time: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchStake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchStartTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    batchUnstake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    cancelTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    claim(overrides?: CallOverrides): Promise<void>;

    claimAndUnstakeForUser(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    createStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    deleteStakingConfig(
      nftAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    enableStaking(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    finishTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    forceCancelTraining(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getActiveTraining(
      overrides?: CallOverrides
    ): Promise<ProfessionStakingHarmony.TrainingStatusStructOutput[]>;

    getActiveTrainingOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<ProfessionStakingHarmony.TrainingStatusStructOutput[]>;

    getAllParticipantData(
      overrides?: CallOverrides
    ): Promise<
      [string[], ProfessionStakingHarmony.NFTStructOutput[][], BigNumber[]] & {
        addresses: string[];
        nfts: ProfessionStakingHarmony.NFTStructOutput[][];
        rewards: BigNumber[];
      }
    >;

    getAllowedSkillChoices(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    getStaked(
      overrides?: CallOverrides
    ): Promise<ProfessionStakingHarmony.NFTStructOutput[]>;

    getStakedOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<ProfessionStakingHarmony.NFTStructOutput[]>;

    getTotalProfessionSkillPoints(
      ntfAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTrainingStatus(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<ProfessionStakingHarmony.TrainingStatusStructOutput>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    initialize(overrides?: CallOverrides): Promise<void>;

    isStakingEnabled(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    modifyActiveTrainingSkill(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    pause(overrides?: CallOverrides): Promise<void>;

    paused(overrides?: CallOverrides): Promise<boolean>;

    pendingRewards(overrides?: CallOverrides): Promise<BigNumber>;

    pendingRewardsOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setGameStorage(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setLastRewardTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setSkillPointer(
      nftAddress: PromiseOrValue<string>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    setTrainingCost(
      level: PromiseOrValue<BigNumberish>,
      cost: PromiseOrValue<BigNumberish>,
      time: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    stake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    startTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    unpause(overrides?: CallOverrides): Promise<void>;

    unstake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    updateStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    withdrawPoolRewards(
      to: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ClaimBlocked(address,uint256,uint256)"(
      from?: PromiseOrValue<string> | null,
      stakedCount?: null,
      amount?: null
    ): ClaimBlockedEventFilter;
    ClaimBlocked(
      from?: PromiseOrValue<string> | null,
      stakedCount?: null,
      amount?: null
    ): ClaimBlockedEventFilter;

    "Claimed(address,address,uint256)"(
      by?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): ClaimedEventFilter;
    Claimed(
      by?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): ClaimedEventFilter;

    "Initialized(uint8)"(version?: null): InitializedEventFilter;
    Initialized(version?: null): InitializedEventFilter;

    "Paused(address)"(account?: null): PausedEventFilter;
    Paused(account?: null): PausedEventFilter;

    "PoolRewardsDeposited(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): PoolRewardsDepositedEventFilter;
    PoolRewardsDeposited(
      from?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): PoolRewardsDepositedEventFilter;

    "PoolRewardsWithdrawn(address,address,address,uint256)"(
      by?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): PoolRewardsWithdrawnEventFilter;
    PoolRewardsWithdrawn(
      by?: PromiseOrValue<string> | null,
      to?: PromiseOrValue<string> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): PoolRewardsWithdrawnEventFilter;

    "RoleAdminChanged(bytes32,bytes32,bytes32)"(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null
    ): RoleAdminChangedEventFilter;
    RoleAdminChanged(
      role?: PromiseOrValue<BytesLike> | null,
      previousAdminRole?: PromiseOrValue<BytesLike> | null,
      newAdminRole?: PromiseOrValue<BytesLike> | null
    ): RoleAdminChangedEventFilter;

    "RoleGranted(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;
    RoleGranted(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleGrantedEventFilter;

    "RoleRevoked(bytes32,address,address)"(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;
    RoleRevoked(
      role?: PromiseOrValue<BytesLike> | null,
      account?: PromiseOrValue<string> | null,
      sender?: PromiseOrValue<string> | null
    ): RoleRevokedEventFilter;

    "Staked(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null
    ): StakedEventFilter;
    Staked(
      from?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null
    ): StakedEventFilter;

    "StakingConfigCreated(address,address,uint256)"(
      nftAddress?: PromiseOrValue<string> | null,
      rewardToken?: null,
      startTime?: null
    ): StakingConfigCreatedEventFilter;
    StakingConfigCreated(
      nftAddress?: PromiseOrValue<string> | null,
      rewardToken?: null,
      startTime?: null
    ): StakingConfigCreatedEventFilter;

    "StakingConfigDeleted(address)"(
      nftAddress?: PromiseOrValue<string> | null
    ): StakingConfigDeletedEventFilter;
    StakingConfigDeleted(
      nftAddress?: PromiseOrValue<string> | null
    ): StakingConfigDeletedEventFilter;

    "StakingConfigUpdated(address,address,uint256)"(
      nftAddress?: PromiseOrValue<string> | null,
      rewardToken?: null,
      startTime?: null
    ): StakingConfigUpdatedEventFilter;
    StakingConfigUpdated(
      nftAddress?: PromiseOrValue<string> | null,
      rewardToken?: null,
      startTime?: null
    ): StakingConfigUpdatedEventFilter;

    "StakingUnlocked(address,address,uint256)"(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null
    ): StakingUnlockedEventFilter;
    StakingUnlocked(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null
    ): StakingUnlockedEventFilter;

    "TrainingCanceled(address,address,uint256,uint256,uint256,uint256)"(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null,
      treeId?: null,
      skillId?: null,
      canceledAt?: null
    ): TrainingCanceledEventFilter;
    TrainingCanceled(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null,
      treeId?: null,
      skillId?: null,
      canceledAt?: null
    ): TrainingCanceledEventFilter;

    "TrainingFinished(address,address,uint256,uint256,uint256,uint256)"(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null,
      treeId?: null,
      skillId?: null,
      level?: null
    ): TrainingFinishedEventFilter;
    TrainingFinished(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null,
      treeId?: null,
      skillId?: null,
      level?: null
    ): TrainingFinishedEventFilter;

    "TrainingStarted(address,address,uint256,uint256,uint256,uint256,uint256,uint256)"(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null,
      treeId?: null,
      skillId?: null,
      level?: null,
      startedAt?: null,
      completeAt?: null
    ): TrainingStartedEventFilter;
    TrainingStarted(
      by?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null,
      treeId?: null,
      skillId?: null,
      level?: null,
      startedAt?: null,
      completeAt?: null
    ): TrainingStartedEventFilter;

    "Unpaused(address)"(account?: null): UnpausedEventFilter;
    Unpaused(account?: null): UnpausedEventFilter;

    "Unstaked(address,address,uint256)"(
      from?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null
    ): UnstakedEventFilter;
    Unstaked(
      from?: PromiseOrValue<string> | null,
      nftAddress?: PromiseOrValue<string> | null,
      tokenId?: null
    ): UnstakedEventFilter;
  };

  estimateGas: {
    DEFAULT_ADMIN_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    GAME_STORAGE(overrides?: CallOverrides): Promise<BigNumber>;

    LAST_REWARD_TIME(overrides?: CallOverrides): Promise<BigNumber>;

    PAUSER_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    UPDATER_ROLE(overrides?: CallOverrides): Promise<BigNumber>;

    adminBatchUpdateNftData(
      addresses: PromiseOrValue<string>[],
      indexes: PromiseOrValue<BigNumberish>[],
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      rewardFrom: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    adminGetData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    adminUpdateNftData(
      _address: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      rewardFrom: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchCancelTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchClaimAndUnstakeForUser(
      addresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchEnableStaking(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchFinishTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchSetTrainingCosts(
      level: PromiseOrValue<BigNumberish>[],
      cost: PromiseOrValue<BigNumberish>[],
      time: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchStake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchStartTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    batchUnstake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    cancelTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claim(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    claimAndUnstakeForUser(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    createStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deleteStakingConfig(
      nftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    enableStaking(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    finishTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    forceCancelTraining(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getActiveTraining(overrides?: CallOverrides): Promise<BigNumber>;

    getActiveTrainingOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getAllParticipantData(overrides?: CallOverrides): Promise<BigNumber>;

    getAllowedSkillChoices(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getStaked(overrides?: CallOverrides): Promise<BigNumber>;

    getStakedOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalProfessionSkillPoints(
      ntfAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTrainingStatus(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    isStakingEnabled(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    modifyActiveTrainingSkill(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    paused(overrides?: CallOverrides): Promise<BigNumber>;

    pendingRewards(overrides?: CallOverrides): Promise<BigNumber>;

    pendingRewardsOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setGameStorage(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setLastRewardTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setSkillPointer(
      nftAddress: PromiseOrValue<string>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setTrainingCost(
      level: PromiseOrValue<BigNumberish>,
      cost: PromiseOrValue<BigNumberish>,
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    stake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    startTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unstake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    updateStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    withdrawPoolRewards(
      to: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    DEFAULT_ADMIN_ROLE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    GAME_STORAGE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    LAST_REWARD_TIME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PAUSER_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    UPDATER_ROLE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    adminBatchUpdateNftData(
      addresses: PromiseOrValue<string>[],
      indexes: PromiseOrValue<BigNumberish>[],
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      rewardFrom: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    adminGetData(
      user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    adminUpdateNftData(
      _address: PromiseOrValue<string>,
      index: PromiseOrValue<BigNumberish>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      rewardFrom: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchCancelTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchClaimAndUnstakeForUser(
      addresses: PromiseOrValue<string>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchEnableStaking(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchFinishTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchSetTrainingCosts(
      level: PromiseOrValue<BigNumberish>[],
      cost: PromiseOrValue<BigNumberish>[],
      time: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchStake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchStartTraining(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    batchUnstake(
      nftAddresses: PromiseOrValue<string>[],
      tokenIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    cancelTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claim(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    claimAndUnstakeForUser(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    createStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      treeIds: PromiseOrValue<BigNumberish>[],
      skillIds: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deleteStakingConfig(
      nftAddress: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    enableStaking(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    finishTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    forceCancelTraining(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getActiveTraining(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getActiveTrainingOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllParticipantData(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getAllowedSkillChoices(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getRoleAdmin(
      role: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getStaked(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getStakedOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalProfessionSkillPoints(
      ntfAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTrainingStatus(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    grantRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    hasRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    initialize(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    isStakingEnabled(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    modifyActiveTrainingSkill(
      _address: PromiseOrValue<string>,
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    pause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingRewards(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    pendingRewardsOf(
      _address: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    revokeRole(
      role: PromiseOrValue<BytesLike>,
      account: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setGameStorage(
      _address: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setLastRewardTime(
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setSkillPointer(
      nftAddress: PromiseOrValue<string>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setTrainingCost(
      level: PromiseOrValue<BigNumberish>,
      cost: PromiseOrValue<BigNumberish>,
      time: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    stake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    startTraining(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      treeId: PromiseOrValue<BigNumberish>,
      skillId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    unpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unstake(
      nftAddress: PromiseOrValue<string>,
      tokenId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    updateStakingConfig(
      nftAddress: PromiseOrValue<string>,
      rewardToken: PromiseOrValue<string>,
      startTime: PromiseOrValue<BigNumberish>,
      maxPointsPerSkill: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    withdrawPoolRewards(
      to: PromiseOrValue<string>,
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;
  };
}
